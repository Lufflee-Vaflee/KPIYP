;Циклы, процедуры, макросы, прерывания, строковые команды

.model small
.stack 100h
.data

    somedata db 20 dup(?);

    ENDLstr                 db  0Ah, 0Dh, '$';

    ;формат заполнения данных при вводе строки прерыванием bios
    string_buf              db 200;     первый байт - максимальный размер
    string_size             db ?;       второй байт - реальный размер(изначально неизвестен)
    string                  db 201 dup('$'); сам буфер символов строки(знак '$' обозначет конец для прерывания вывода строки bios)

.code

    enter_str   macro   enterAdress; макросы поддерживают параметры - при использование макроса, параметр просто вставиться(буквально текстом) во все места его использования

        push    AX;     стандартный вариант использования стека
        push    DX;     ;сохраняем значения регистров использующихся в макросе, чтобы вызывающий код, мог расчитывать на выполнение операции без задевания других служебных данных

        mov     AH,     0Ah;
        lea     DX,     enterAdress;
        int     21h;

        pop     DX;
        pop     AX;

    endm

    output_str  macro   outputAdress;

        push    AX;
        push    DX;

        mov     AH,     09h;
        lea     DX,     [outputAdress + 2];
        int     21h;

        pop     DX;
        pop     AX;

    endm

    endl        macro

        push    AX;
        push    DX;

        mov     AH,     09h;
        lea     DX,     ENDLstr;
        int     21h; 

        pop     DX;
        pop     AX;

    endm


    exit        macro 

        mov     AX,     4c00h;
        int     21h;

    endm

    clearBuf    macro   strBuf

        push    CX;
        push    AX;
        push    DI;

        xor     CX,     CX;
        xor     AX,     AX;


        mov     CL,     strBuf;
        lea     DI,     strBuf + 1;
        mov     AL,     '$';

        rep    stosb;


        pop     DI;
        pop     AX;
        pop     CX;

    endm;

    start:

    mov ax, @data;      ;установка сегментов es и ds
    mov ds, ax;
    mov es, ax;

    ;Циклы

    mov cx, 20;               ;cx - кол-во 
    mov di, offset somedata;  ;получаем адресс массива
    CYCLE_LOOP:               ;стандартный формат цикла, аналогичен синтаксису высокоуровневых языков - do { }while(statement); т.е. первая итерация цикла всегда выполниться

        mov ax, [di];         ;Добавляем ко всем элементам массива 10
        add ax, 10;
        mov [di], ax;         ;и заносим результат обратно


        inc di;               ;идем дальше по массиву
    loop CYCLE_LOOP;          ;команда loop особый формат условного перехода, при каждом выполнении уменьшает cx на единицу, и если cx не равен нулю переходит на метку


    mov cx, 20;
    mov di, offset somedata;
    CYCLE_JNZ:

        mov ax, [di];
        add ax, 10;
        mov [di], ax;


        inc di;
        dec cx;
        cmp cx, 0;
    jnz CYCLE_JNZ;  аналогичный предыдущему цикл, но с использованием обычной метки


    mov cx, 20;
    mov di, offset somedata;
    CYCLE_WHILE:        ;аналогичен синтаксису высокоуровневых языков - while(statement) {}; т.е. первая итерация цикла может не выполниться, что обрабатывает крайний случай, предпочтительный способ
    cmp cx, 0;
    je  CYCLE_BREAK;

        add ax, 10;
        mov [di], ax;

        inc di;
        dec cx;
    jmp CYCLE_WHILE

    CYCLE_BREAK:

    ;строковые команды
    ;существуют специальные циклические команды, способные выполнить множество одинаковых операций над данными одной строкой
    ;условно их называют строковыми, хотя их использование не ограничивается только байтовыми массивами
    mov si, offset somedata; как будет видно ниже инициализация si и di необходима, как впрочем и es, ds, что уже сделано в начале программы
    mov di, offset somedata;
    mov al, 10;            ; и ax в том числе
    cmpsb; сравнивание элемента ds:si с элементом es:di
    scasb; сравнивание значения al с элементом es:di
    movsb; пересылка элемента ds:si в es:di
    stosb; запись из al в es:di
    lodsb; запись в al из ds:si

    mov si, offset somedata;
    mov di, offset somedata;
    mov ax, 10;
    ;последняя буква команды указывает на размерность b - byte, w - word(2 байта)
    ;все команды ниже аналогичны предыдущим, но работают с ячекой памяти размером два байта и регистром ax
    cmpsw; 
    scasw; 
    movsw; 
    stosw; 
    lodsw; 

    mov si, offset somedata;
    mov di, offset somedata;
    ;в таком формате использование команд практически бессмысленно, их всегда используют вместе с префиксом повторения rep
    ;подобно loop в таком случае команда будет выполняться заданное в cx количество раз, постепенно обнуляя cx
    ;а также увеличивая значение di, si, либо и того и другого на 1 - для байтового формата, или на 2 - для слов
    mov cx, 20;

    rep movsb;

    mov si, offset somedata;
    mov di, offset somedata;
    mov cx, 10;
    rep movsw; вариант со словами
    
    ;выполнение команды можно "развернуть" в обратную сторону, уменьшая di и si, вместо увеличения
    std; - в обратную сторону, di, si - уменьшаются
    cld; - прямо, di, si - увелич
    ;хотя инициализация направлениваются(значение по умолчанию)ия не требуется, т.к. есть значение по умолчанию, лучше все же явно прописать cld
    ;во-первых это спасет, если в другом месте программы, было выполнени std, и явно укажет в каком направлении должны работать команды

    ;также существует еще два префикса, позволяющих выйти из циклической операции до того как обнулиться cx используемых с командами scasb(w) cmpsb(w)
    mov di, offset somedata;
    mov al, ' ';
    mov cx, 20;
    repne scasb; повторять пока значения строки совпадают с al, либо cx = 0

    mov si, offset somedata;
    mov di, offset somedata;
    mov al, 10;
    mov cx, 20;
    repne cmpsb; повторять пока значения строк ds:si и es:di не совпадают, либо cx = 0

    ;у данных команд при выходе по условию есть одна особенность:
    ;после нахождения элемента, удовлетворяющего выходу из циклической операции - di(и si) все равно увеличивается на 1, а cx - уменьшается на 1
    ;т.е. после выполнения операции di - будет указывать на следующий за найденным элемент, поэтому зачастую для получения ожидаемого результата после данной операции следует откатить эти изменения:
    dec di; (при cld)
    inc cx;


    ;немного о стеке
    ;стек - вложенная в программу структура данных предоставляющая доступ к верхнему элементу, ss:sp - пара отвечающая за адресацию вершины
    push ax; заносим в стек слово
    push bx; заносим в стек слово

    pop  bx; забираем bx из стека
    pop  dx; забираем ax из стека, возвращать значение из стека не обязательно в тот же регистр, который его туда заносил

    ;заносить в стек можно только слово
    ;push al данный код не скомпилируется

    ;стек - такая же область памяти как и data, для адресации по нему можно использовать дополнительный регистр - bp
    mov bp, sp;
    mov ax, [bp]
    ;и даже индексные регистры
    mov di, sp;
    mov ax, ss:[di]; только нужно явно указать, что смещаемся от сегмента стека

    ;кроме простого сохранения значений, практических применений у стека множество, отдельно обcуждать их не будем они будут более ясны в контексте будущих примеров


    ;макросы
    ; суть макросов крайне проста - код который используется множество раз множно записать в макрос и он целиком вставиться на место его "вызова" на этапе компиляции программы
    enter_str string_buf;
    endl;
    output_str string_buf;
    endl;
    clearBuf string_buf;

    ;процедуры
    ; процедуры в отличии от макросов не вставляются в код на этапе компиляции, а работают по несколько иному принципу
    ; который в целом похож на механику безусловного перехода jmp, с той лишь разницей, что процедура подразумевает возвращение на место вызова
    ; механизм возврата работает через стек:
    ; при вызове процедуры текущие значения ip или cs:ip(зависит от модели программы и синтаксиса объявления функции) заносится в стек
    ; после чего прямо как в случае с jmp значение ip или cs:ip(...) меняется на адрес процедуры, которая начинает исполняться
    ; пока не наткнется на команду возврата, которая вытаскивает из вершины стека сохраненные при вызове ip или cs:ip
    ; из чего следует вывод, что на совести программиста, остается возврат указателя стека в то же состояние, что и при вызове, как и целостность данных в нем
    ; иначе - в ip или cs:ip занесется некорректное значение и программа весело пойдет интерпритировать как команды область памяти, которая таковой не явлеяется или явлется, но слегка не с того места
    ; либо если поймет, что значение некорректны обнулит ip, а в cs занесет адрес сегмента кода и начнет исполнение программы заново
    ; в основной процедуре некорректная обработка стека в худшем случае привет лишь к утечкам памяти
    ; даная ошибка самая распространенная при работе с процедурами и поэтому требует особенно бережного обращения со стеком внутри процедур, особенно если стек используется как часть алгоритма

    mov ax, 35;
    call Unsigned16Num_output;  вызов процедуры
    ; в отличие от макросов синтаксического способа передачи параметров в процедуру нет
    ; способ передачи и возврата данных из процедуры разработчик волен выбирать сам
    ; это может быть как обасть памяти, буть то переменная или стек, либо какой-либо из регистров


    ;прерывания
    ; прерывания по сути свой представляют ту же самую процедуру, лишь с парочкой отличий
    ; прерывание не вызвается на прямую, а запрашивается через специальную таблицу прерываний в операционной системы(в данном случае dos и bios)
    ; а вот уже в самой таблице записаны пары cs:ip, которые и ссылаются, на уже знакомые процедуры(а точнее обработчики прерываний)
    ; при вызове прерывания кроме cs:ip в стек заноситься и регстр флагов, который восстанавливается при возврате, командой iret
    ; в операционной системе существуют заранее предоставляемые обработчики прерываний
    ; тем не менее существует большое пространство номеров прерывание зарезервированных для разработчика
    ; записав в эти номера адреса своих процедур можно вызывать их таким же способом как и предустановленные
    ; более того даже предустановленные прерывания мнжно заменить на свои собвстенные, или написать над ними обертку
    ; однако это выходит за рамки темы


    ;сравнение макросов и процедур, плюсы и недостатки в сравнении друг с другом
    ; макросы позволяют избежать процедуры записи и возврата из памяти cs:ip, что может сильно сказаться на производительности особенно в циклах
    ; макросы предоставляют удобную передачу параметров, а также меньшее кол-во проблем при некорректной обработки стека
    ; хотя использование меток в макросе возможно, такой макрос нельзя будет использовать больше 2 раз, 
    ; т.к. это приведет к образованию двух одинаковых меток на этапе компиляции, что нивелирует все преимущества макроса
    ; макросы намного тяжелее отлаживать, т.к. двоичный формат кода начинает несоответствовать тексту
    ; макросы не имеют вохможности вызова самих себя и следовательно не позволяют реализовывать рекурсивные алгоритмы


    exit

    Unsigned16Num_output    proc;       ax - num

    PUSH BX;        для макросов сохранение значение вовсе не обязательно
    PUSH CX;        и хотя процедуры также не обязывают это делать, это можно сказать обязательное правило хорошего тона, которое сильно упростит вам работу с процедурами
    PUSH DX;

    mov BX, 10;
    mov cx, 0;
    cycle1:

        xor dx, dx;
        div bx;
        push dx;            как и обещано пример использование стека вне контекста сохранения значений регистров
        inc cx;             здесь в стек многократно заносится остаток от деления числа на 10, т.е. его будущие символы для вывода
    cmp ax, 0;
    jnz cycle1

    cycle2:

        pop dx;             формат возврата данных из стека в данном контексте крайне удобен, ибо позволяет в обртном порядке получать остатки числа, что и нужно для вывода
        add dl, '0';
        mov al, dl;
        mov ah, 06h;
        int 21h;

    loop cycle2

    pop DX;
    pop CX;
    pop BX;
    ret;        возвращаемся из процедуры

Unsigned16Num_output    endp

end start