;Кратко о командах процессора по группам(кроме mov)

.model small
.stack 100h
.data

    somevar1 db 32;
    somevar2 dw 10;

.code

    start:

    mov ax, @data;      ;установка сегментов es и ds
    mov ds, ax;
    mov es, ax;

    mov ax, 10;
    mov cx, 16000;
    mov bx, 12;
    mov dx, 361;
    ;арифметические команды

    ;сложение
    add ax, bx;
    add ah, dh;
    add ax, [somevar2];

    ;вычитание
    sub cx, dx;
    sub cl, dl;
    sub dx, ax;

    ;инкрементирование и декрементирование
    inc ax;         увеличит ax на единицу
    dec ax;         уменьшит ax на единицу

    ;сравнения безусловный и условные переходы
    jmp mark1; безусловный переход
    mov ax, 3; данная строчка никогда не выполниться
    mark1:   ; метка перехода

    ; все условные переходы напрямую связаны с регистром флагов, значение которых меняются при операции между двумя числами, относительно результата
    ; все вышеперечисленные арифметические команды меняют состояния флагов, что уже можно использовать для условных переходов
    cmp ax, bx; в случае же если мы хотим просто сравнить два числа, при этом никуда не записывая результат, можем воспользоваться командой cmp
    sub ax, bx; cmp заполняет регистр флагов точно так же как и команда sub, только не меняя источник
    ;для понимания какой оператор ветвления вам необходим можно пользоваться соответствующей таблицей флагов
    ;однако намного проще понять мнемонику команд ветвления:
    ; j - первая буква, присутствующая во всех команда ветвления, обозначающая jump - прыжок
    ; a/b - ander/below - если больше/меньше для беззнаковых
    ; g/l - greater/lower - если больше/меньше для знаковых
    ; e - equal - если равно
    ; z - zero - если нуль, (полностью эквивалентно e-записи, т.к. при вычитании двух равных получается собственно нуль - смеотреть выше)
    ; n - not - меняет последующую мнемонику на обратную(ne - не равно, ng - не больше и т.д.)

    ;а также несколько редко используемых, но для справки укажем
    ;o - overflow - переполнение
    ;p - parity - четность
    ;s - sign - есть знак

    jmp mark2; т.к. автор конечно мог сделать красивый пример с множеством меток, при котором они все выполняются/не выполняются и в конечно итоге идут дальше по коду, но он поленился
             ; поэтому все метки далее мы обойдем, а напишем их чисто для справки и примера
    cmp dx, cx;
    je mark2; переход если равны
    jz mark2; переход если результат условного вычитания(cmp) - нулевой, т.е. dx == cx, эквивалентно прошлой команде
    jne mark2; переход если не равны
    jg mark2; переход если dx больше
    jng mark2; переход если dx не больше(меньше или равен)
    jle mark2; переход если dx меньше или равен(аналогичен предыдущему)
                ; js SF, jo OF 

    mark2:
    ;на первый взгляд может показаться, что метки с разным названием, но одинаковым функционалом бесполезны и нужно использовать только одну из них
    ;однако это позволяет более подробно описывать почему вам нужен тот или иной переход в коде, поэтому практическая польза имеется и она такая же как от хорошо названных переменных
    ; - лучшая читаемость и понятность кода


    ;обе арифметические команды справедливо работают и для дополнительного кода, отрицательных чисел, что легко вывести математически, но если вам лень - можете просто поверить

    ;умножение, всегда выполняется над al, ax регистром, что определяется размером множителя
    mul cl; 
    ;результат записывается туда же - в ax, причем результат в два раза больше размером чем размеры множителей
    mul cx;
    ;в случае умножения двух слов результат запишется в пару dx:ax, где dx - старшая часть, а ax - младшая
    ;из чего следует вывод, что использовать dx, dl и dh как один из множителей нежелательно, ибо при нескольких умножениях, его состояние тяжело контролировать


    ;деление, также выполняется либо над ax, либо над парой dx:ax, делитель всегда в два раза меньше размером, чем размер делимого


    div cl; в данном случае выполняется деление ax на cl, результат будет записан в al, а остаток - в ah
    div cx; делимое dx:ax, dx - остаток, ax - результат;

    ; хотя сама по себе операция деления не обеспечивает умещаемость результата в два раза меньший размер - он должен быть таковым(dx или ah в результате деления должны обнулиться для записи в них остатка)
    ; иначе это вызовет некорректную работу программы
    ; т.е. логика программы должна обеспечивать это условие, перед выполнением деления, иными словами либо делимое гарантированно мало, либо делитель гарантированно велик
    ; поэтому лучше всегда использовать вариант dx:ax с обнуленным dx даже, если делимое занимает только 1 - 2 байта, это гарантированно не приведет к данной проблеме, т.к. dx уже обнулен

    ;деление на нуль также вызывает некорректную работу программы, а именно вызов системного прерывания 0h
    ; как и любое прерывание - его можно переопределить, и прописать собственную логику работы программы в таком случае, но это выходит за рамки темы

    ;также существуют команды близнецы, работающие по точно такой же логике, но интерпритирующие ax как знаковое число в дополнительном коде
    imul cx;
    mov  dx, 0;
    idiv cx;


    mov al, 00101001b;
    mov bl, 00000001b;
    mov cl, 10000011b;
    mov dl, 11111011b;
    ;логические команды
    ;логика работы данных команд проста - заявленная логическая операция выполняется между каждыми из битов приемника и источника, соответствующих позиций;
    ;как видно выше битовая запись очень удобна для работы в таком случае

    xor al, bl; al - 00101000b
    and cl, bl; cl - 00000001b
    or  dl, al; dl - 11111011b

    ;унарные операции, источник отсутствует, а операция выполняется только над приемником
    not bl;     bl - 11111110b вычисление обратного кода - каждый из битов меняется на противоположный
    neg bl;     bl - 00000010b вычисление дополнительного кода - каждый из битов меняется на противоположный, а к результату добавляется единица
    ;как не трудно догадаться neg позволяет поменять "знак" числа на противоположный, если вы интерпитируете значение регистра как знаковое число
    not bl;     две эти строчки дадут такой же результат как и neg
    inc bl;

    xor al, al; выношу данную строчку отдельно, т.к. она часто используется в коде
    ;вычисление исключаещего или числа от себя самого приведет к его обнулению, что, наверное, почти очевидно, но на всякий случай нарисую табличку функции xor
    ; x1  x2  xor
    ; 0   0   0 
    ; 0   1   1
    ; 1   0   1
    ; 1   1   0 

    ; и пример его исполнения 
    ; al - 01010010b
    ; XOR  ||||||||
    ; al - 01010010b
    ; ||   ||||||||
    ; f    00000000b

    mov al, 0; логическая операция xor выполняется в разы быстрее, чем занесение из памяти константы, 
    ;хотя скорее всего при включении опции оптимизации компилятор заменит эту строчку за вас на xor ax, ax

    ;       76543210 - пронумеруем биты для наглядности
    mov al, 10101001b;
    ;сдвиги хотя по хорошему счету, это тоже логические операции, но расмотрим их отдельно
    ;все сдвиги выполняют одну и ту же операцию - пермещают биты регистра либо влево, либо вправо
    ;отличаются они лишь тем, что делают с одной крайней освободившейся ячейкой и лишним выкинутым битом

    ;логические сдвиги
    shl al, 1; al - 01010010b сдвигаем на 1 бит влево - освободишаяся ячейка заполняется нулем, старший бит переноситься в CF - 1
    shr al, 1; al - 00101001b сдвигаем на 1 бит вправо - освободишаяся ячейка заполняется нулем, младший бит переноситься в CF - 0
    ;как видно при данном свдиге вполне реально потерять изначальное значение al
    ;сдвигать можно и на несколько битов, флаг CF при этом будет формировать "последний вышедший"
    shl al, 3; al - 01001000b сдвигаем на 3 бита влево - освободишаяся ячейка заполняется нулем, пятый бит переноситься в CF - 1
    shr al, 3; al - 00001001b сдвигаем на 3 бита вправо - освободишаяся ячейка заполняется нулем, нулевой бит(на момент после предыдущего сдвига) переноситься в CF - 0

    mov al, 10101001b;
    ;арифметические сдвиги
    sal al, 1; - арфиметичесий свдиг влево, никак не отличается от shl
    ; арифметический свдиг вправо заполняет знак CF точно также как и shr, однако сохраняет значение старшего бита(№7), и соответственно заполняет его значением нужное количество ячеек справо от себя
    sar al, 1; al - 11010100b
    sar al, 3; al - 11111010b

    mov al, 10101001b;
    ;циклические свдиги
    ;принцип работы их схож с логическими сдвигами, однако для заполнения освободившихся ячеек, используется значения выкинутых битов, проходящих через CF, из-за чего число как бы "едет по кольцу"
    ror al, 3; al - 00110101b;
    ror al, 2; al - 01001101b;
    ror al, 3; al - 10101001b; - вернулись обратно
    rol al, 8; al - 10101001b; - и еще один круг в другую сторону

    ;практическое применение сдвигов
    ;самое частое применение - это выполнения операция умножения и деления на степени двойки
    ;такой способ в разы быстрее, и выполняется не только на ax регистром
    ;также часто может пригодиться при общении с реальным устройством, у которого разные параметры упакованы в 1 байт по разным битам
    ;также данным способом можно проверять значение знака в альтернативу команде jc, перенося крайний левый бит в флаг CF

    mov ax, 4C00h;
    int 21h;

end start